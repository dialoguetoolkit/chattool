/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package diet.task.mazegame;

/**
 *
 * @author user
 */
import diet.attribval.AttribVal;
import diet.client.ClientInterfaceEvents.ClientInterfaceEventTracker;
import java.awt.Dimension;
import java.awt.event.KeyEvent;
import java.util.Date;

import javax.swing.SwingUtilities;

import diet.client.ConnectionToServer;
import diet.debug.Debug;
import diet.message.MessageTask;
import diet.task.ClientTaskEventHandler;
import diet.task.mazegame.message.*;
import java.awt.Color;

/**
 * This deals with events generated by the maze game, local client keyboard input and maze game messages received
 * from the server.
 * <p>It unpacks messages from the server and generates messages to be sent to the server. 
 * 
 *
 * @author user
 */
public class ClientMazeGameComms extends ClientTaskEventHandler {
  //private ConnectionToServer cts;
  //private Socket kkSocket = null;
  //ObjectOutputStream out = null;
  //ObjectInputStream in = null;
  JMazeFrame jmf;
 
  Game gam ;// = new Game("Empty");
  String dispMessage = null;
  //String serverName;
  //int isDirector=0;//0 if dyadic. 
                   //1 if triadic and client is director. 
                   //2 if triadic and client is not director
  Date timeOfLastKeyPress = new Date();

  public ClientMazeGameComms(final ConnectionToServer cts,final MessageNewMazeGame mng){
      super(cts);
      final ClientMazeGameComms cmgc = this;
      
        SwingUtilities.invokeLater(new Runnable(){
            public void run(){
              try{  
                jmf = new JMazeFrame();
                System.err.println("HEREB2");
                jmf.setComms(cmgc);
                System.err.println("HEREB3");
                jmf.setVisible(true);
                System.err.println("HEREB4");
                processNewGameRequest(mng);
               System.err.println("HEREB5");
               //this.setDisplayMessage("Waiting for other computers to connect....");
        
            }catch (Exception e){
               System.err.println(e.getMessage().toString());
               System.out.println("STACKTRACE:");
               e.printStackTrace();
             }  
            }
        
        });
        
  }
  
  public void changeBorderOfMazeFrame(final int pixelwidth, final Color colour){
      try{
            SwingUtilities.invokeLater(new Runnable(){
                public void run(){
                     jmf.jfgp.changeBorder(pixelwidth, colour);
                     jmf.repaint();
                     jmf.jPanel3.repaint();
                }
            });  
  }catch(Exception e){
              System.err.println("ERROR CHANGING BORDER "+e.getMessage().toString());
   }
      
  }
  
  public void repaintJMazeFrame(final String clientinterfaceventname, final boolean sendEventToServer){
      try{
            SwingUtilities.invokeLater(new Runnable(){
                public void run(){
                     long timeOfEvent = new Date().getTime();
                     jmf.jPanel3.repaint();
                     AttribVal av2 = new AttribVal("dummyattribval","dummyvalue");
                     if(sendEventToServer) cts.cEventHandler.reportInterfaceEvent(clientinterfaceventname, timeOfEvent, av2);
                             
                }
            });  
  }catch(Exception e){
              System.err.println("ERROR REPAINTING MAZE "+e.getMessage().toString());
   }
}  

  /**
   * Processes messages that arrive from the server. The types and contents of these 
   * messages are used to determine appropriate updates to the local maze game.
   * @param mt
   */
  public void processTaskMove(MessageTask mt){
       if (mt instanceof MessageChangeGateStatus) {
          final MessageChangeGateStatus mscgs = (MessageChangeGateStatus) mt;
          
          boolean gatesAreOpenInState0 = jmf.jPanel3.maz.gatesOpen;
          boolean gatesAreOpenInState1 = mscgs.gatesAreOpen();
          
          jmf.jPanel3.maz.gatesOpen = mscgs.gatesAreOpen();
          String eventtype = "";
          
          if(!gatesAreOpenInState0& gatesAreOpenInState1)  eventtype = ClientInterfaceEventTracker.mazegameOpenGates;
          if(gatesAreOpenInState0& !gatesAreOpenInState1   )eventtype = ClientInterfaceEventTracker.mazegameCloseGates;
          
          
          
          repaintJMazeFrame(eventtype,true);
          //this.setDisplayMessage(null);
        }
        else if (mt instanceof MessageNextMaze_SentAsIndex) {
          final MessageNextMaze_SentAsIndex mnm = (MessageNextMaze_SentAsIndex)mt;
          System.err.println("ATTEMPTING TO MOVE MAZE TO: "+mnm.getNext());
          SwingUtilities.invokeLater(new Runnable(){
              public void run(){
                     processNextGameRequest(mnm.getNext(),mnm.getGame(),mnm.getDisplayText());
           }   
          });
          
          
        }
        else if (mt instanceof MessageNextMaze_SentAsMaze) { //Dont use this
          //MessageNextMaze_SentAsMaze mnMaze = (MessageNextMaze_SentAsMaze)mt;
          //System.err.println("ATTEMPTING TO MOVE MAZE TO: "+mnm.getNext());
         // processNextGameRequest(mnm.getNext());
        
        }
        else if (mt instanceof MessageStartGame){
          MessageStartGame msg = (MessageStartGame) mt;
          this.setDisplayMessage(null);
          repaintJMazeFrame("",false);
        }
        else if (mt instanceof MessageWaitForOthersToCatchUp){
          MessageWaitForOthersToCatchUp msg = (MessageWaitForOthersToCatchUp) mt;
          this.setDisplayMessage(msg.getText());
          repaintJMazeFrame("",false);
        }
       
  }


  

  /**
   * Constructs a message containing the position of the marker within the maze game.
   * @param d2
   */
  public void sendCursorPos(Dimension d2) {
      System.err.println("HERET - SENDCURSORPOS");
      int mazeGsmeNo =-1;
      try {
      
      try{
        mazeGsmeNo = gam.getAllMazes().indexOf(jmf.jPanel3.maz);
      }catch (Exception e){
          e.printStackTrace();   
      }  
      MessageCursorUpdate mscu = new MessageCursorUpdate(cts.getEmail(),cts.getUsername(), d2, mazeGsmeNo);
      
      
      
      cts.sendMessage(mscu);
      
      //out.writeObject(mscu);
      //out.flush();
    }
    catch (Exception e) {
      System.out.println(e.getMessage());
    }

  }

  /**
   * Receives keypresses typed locally by the client and relays them to the maze game. 
   * Initial filtering of keypresses is handled by @link ClientEventHandler.
   * @param e
   */
  public void relayKeypressToMazeFrame(KeyEvent e){
      System.err.println("HERET - RELAYING KEYPRESS TO MAZE FRAME");
      jmf.keyPressFilter(e);
  }
  
  /**
   * Receives the keycodes of the keys typed locally by the client and relays them to the maze game. 
   * Initial filtering of keypresses is handled by {@link diet.client.ClientEventHandler}.
   * 
   * @param e key pressed
   */
  public void relayKeyReleaseFilterToMazeFrame(KeyEvent e){
      jmf.keyReleaseFilter(e);
      System.err.println("HERET - RELAYING KEYRELEASE TO MAZE FRAME");
  }
  
  /**
   * Returns the String currently being displayed in the Maze Game window (distinct from the JChatFrame)
   * @return message displayed in the maze game window
   */
  public String getDisplayMessage() {
    return this.dispMessage;
  }

  /**
   * Displays the String in the Maze Game window
   * @param msg
   */
  public void setDisplayMessage(String msg) {
    dispMessage = msg;
    jmf.jPanel3.paint(jmf.jPanel3.getGraphics());
    
  }

  /**
   * Retrieves list of mazes from message sent by server and initializes the maze game to the first maze.
   * @param msng
   */
  private void processNewGameRequest(MessageNewMazeGame msng) {
    System.err.println("HEREC1");
    gam = msng.getGame();
    System.err.println("HEREC2");
    //gam.clientName = cts.getUsername();
    System.err.println("HEREC3");
    jmf.jPanel3.maz = gam.getMazeNo(0);
    System.err.println("HEREC4");
    jmf.jPanel3.resetCursorToBegin();
    System.err.println("HEREC5");
    jmf.jPanel3.paint(jmf.jPanel3.getGraphics());
    System.err.println("HEREC6");
    jmf.jPanel3.resetCursorToBegin();
    System.err.println("HEREC7");
    
  }

  public void debugMoveCursorToGOAL(){
      jmf.jPanel3.maz.moveTo(new Dimension(jmf.jPanel3.maz.finish.x, jmf.jPanel3.maz.finish.y));
      jmf.cms.sendCursorPos(new Dimension(jmf.jPanel3.maz.current.x, jmf.jPanel3.maz.current.y));
  }
   
  
  
  
  
  public void displayMessageInWindow(String text, long lengthOfTime){
       setDisplayMessage(text);
       repaintJMazeFrame("",false);
       try {
          if(lengthOfTime>0)this.sleep(lengthOfTime);
       }
       catch (Exception e) {}
       if(lengthOfTime>0)setDisplayMessage(null);
  }
  
  
  
  /**
   * Called when all participants in maze game are on their respective goals. Selects and displays the next maze
   * in the Vector of stored mazes
   * @param i
   */
  private void processNextGameRequest(int i, Game g, String message) {
   try{
    if(g!=null){
        this.gam=g;
    }   
    
    
    
    int maxGameNo = gam.getAllMazes().size();
    jmf.jPanel3.maz = (Maze)gam.getAllMazes().elementAt(i);//gam.nextMaze();
    jmf.jPanel3.resetCursorToBegin();
    setDisplayMessage(message);
    repaintJMazeFrame("",false);
    try {
      this.sleep(2000);
    }
    catch (Exception e) {}
    setDisplayMessage(null);
    jmf.jPanel3.resetCursorToBegin();
    jmf.jPanel3.maz.moveTo(new Dimension(0,0));
    jmf.jPanel3.maz.changeGates(false);
    
    System.out.println("processing next game request");
    repaintJMazeFrame("",false);
    
    
    
    
   }catch (Exception e){
       System.err.println("ERROR PROCESSING NEXT GAME REQUEST: "+i);
       e.printStackTrace();
   } 
  }

  private void resetWaitingForNextExperiment() {
    setDisplayMessage("Experiment Finished.");
    try {
      this.sleep(1000);
    }
    catch (Exception e) {}

  }
  
   public void closeDown(){
     try{
       jmf.setVisible(false);
       jmf.dispose();
       jmf = null;
     }catch (Exception e){
        System.err.println("Could not close down the maze properly: "+e.getMessage());
     }  
   }
  
}
